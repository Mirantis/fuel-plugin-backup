#!/bin/bash

DEBUG=true
CREATE_BASE=false

function show_usage {
    echo "Usage:"
    echo "  $0 command"
    echo
    echo "Available commands: (Note: work in progress)"
    echo "help: show this message"
    echo "Options:"
    ${GREEN}
    echo "  --debug    : to show some debug messages"
    ${RESET}
    echo "Commands  :"
    echo "  boot: to boot up node"
    echo
    echo "Examples:"

}

function parse_options {
    opts="$@"
    for opt in $@; do
      case $opt in
        -d|--debug)   DEBUG=true
                      shift
                      ;;
        --nodebug)    DEBUG=false
                      shift
                      ;;
        --folder)     shift
                      SOURCE=$2
                      ;;
        --)           shift
                      nonopts+=("$@")
                      return
                      ;;
        help|boot|deploy|start|stop|remove)
                      nonopts+=("$@")
                      return
                      ;;
        -*)           ${YELLOW}
                      echo "Unrecognized option: $opt" 1>&2
                      ${RESET}
                      exit 1
                      ;;
        *)            nonopts+=("$opt")
                      ;;
      esac
    done
}


function backup {

  pid                                      ## Create lock-file

  list                                     ## Just information
  make_dir_if_not_exist                    ## Create Skeleton
  save_metadata                            ## Metadata, wiil use it to understand the image size

  create_not_create                        ## If we have new images, let's create new base-snapshots
  if [ $CREATE_BASE == true ] ; then
    create_snapshots $BASEMARKER           ## Every day snapshot to make DIFF from base to it
    export_base_images                     ## Need to create if there is no Base images or other cases
  else
    create_snapshots $MARKER               ## Every day snapshot to make DIFF from base to it
    export_diff_from_base_to_now
  fi
  delete_old_snapshots $MARKER             ## If snapshot count more
  delete_old_snapshots $BASEMARKER         ## If snapshot count more
  update_index                             ## User information about where base image is stored

}

function restore {

  find_nearest_base $SOURCE                 ## Check the path and find the proper base image
  pid
  check_the_path $SOURCE

#  list                                      ## Just information
#  import_base
#  import_diffs
#  update_index                             ## User information about where base image is stored
}


function pid {
  # Am I Running
  if [ -f "${LCK_FILE}" ]; then
    MYPID=`head -n 1 $LCK_FILE`
    while [ -n "`ps -p ${MYPID} | grep ${MYPID}`" ]
    do
      echo `basename $0` is already running [$MYPID].
      exit
    done
  fi
  echo $$ > $LCK_FILE
}

function import_base {

  rbd import --image-format 2 /tmp/img mypool/myimage2

}

function import_diffs {

  rbd import-diff /path/to/diff backup_image

}

function find_nearest_base {

  for pool in ${POOLS[@]}; do
    images=$(rbd -p $pool ls 2>/dev/null)
    for image in $(echo $images); do
      restore_from=`echo "$1" | sed -e 's#^'$BACKUP'/backup-##' | sed -r 's#/##'`
      debug Starting restoration from: $restore_from
      rc=`rbd snap ls $pool/$image | grep -v "SNAPID" | sort -n | grep $restore_from &> /dev/null; echo $?`
      if [[ "$rc" > "0" ]]; then
        ${YELLOW}
        echo "There is no diff for $image for this date - $restore_from , skipping"
        ${RESET}
        continue
      fi
      declare -a base_array_date=(`rbd snap ls $pool/$image | grep -v "SNAPID" | sort -n | grep base | awk '{print $2}' | sed -e 's#'$BASEMARKER'-'$image'-##'`)
#      for base in $base_array_date{@} ; do
#        if [ "$restore_from" == "$base" ] ; then
#           debug iploading base image without any diffs
#        elif [[ "$base" > "$restore_from" ]] ; then
       echo ${base_array_data[@]}



#  rbd import-diff /path/to/diff backup_image

     done 
done

}

function check_the_path {

  rc=`echo "$1" | grep $BACKUP &> /dev/null; echo $?`
  if [[ ! -e "$1" ]]; then
    ${RED}
    echo "Check the path, there is no such folder - $1"; 
    ${RESET}
    exit 1
  elif [[ "$rc" > "0" ]]; then
    ${RED}
    echo "Check the path, should be like $DEST"; 
    ${RESET}
    exit 1
  fi

}


function create_not_create {

  #if there is no base images
  for pool in ${POOLS[@]}; do
    images=$(rbd -p $pool ls 2>/dev/null)
    for image in $(echo $images); do
      base_images_count=`rbd snap ls $pool/$image | grep -v "SNAPID" | grep base | sort -n | head -n 1 | awk '{print $2}' | wc -l`
      if [ "$base_images_count" -eq "0" ] ; then
        CREATE_BASE=true
      fi
    done
  done
  return
}

function make_dir_if_not_exist {

  if [ -d $DEST ]; then
    debug Destination folder already exists
  else
    debug "creating folder $DEST"
  fi
    for pool in ${POOLS[@]}; do
      debug creating $DEST/$pool
      mkdir -p $DEST/$pool
      images=$(rbd -p $pool ls 2>/dev/null)
      for image in $(echo $images); do
        debug creating $DEST/$pool/$image
        mkdir -p $DEST/$pool/$image
      done
    done

  debug "checking index file"
  if [ -e $INDEX ]; then
    debug $INDEX already exists
  else
     echo "#index file do not remove" > $INDEX
  fi

}

function list {

  for pool in ${POOLS[@]}; do
    debug list of images for pool $pool
    rbd -p $pool ls

    images=$(rbd -p $pool ls 2>/dev/null)
    for image in $(echo $images); do
      debug list of snapshots for_image $pool/$image
      rbd snap ls ${pool}/${image}
    done
  done
}

function purge {

  for pool in ${POOLS[@]}; do
    images=$(rbd -p $pool ls 2>/dev/null)
    for image in $(echo $images); do

      rbd snap ls ${pool}/${image}
      rbd snap purge ${pool}/${image}

    done
  done
}

function save_metadata {

  for pool in ${POOLS[@]}; do
    images=$(rbd -p $pool ls 2>/dev/null)
    debug Images: $images
    numimages=$(echo $images|sed '/^$/d'|wc -l)
    debug number of images $numimages
    if [ "$numimages" -eq 0 ]; then
        continue;
    fi
    echo $images > $DEST/$pool/images
    rados -p $pool get rbd_directory $DEST/$pool/rbd_directory

    for image in $(echo $images); do
        rbd -p $pool info $image > $DEST/$pool/$image.info
    done

  done

}

function create_snapshots {

  for pool in ${POOLS[@]}; do
    images=$(rbd -p $pool ls 2>/dev/null)
    for image in $(echo $images); do
      debug creating $1 snapshot for: $pool/$image with name $1-${image}-${SUFFIX}
      rbd -p $pool snap create --snap $1-${image}-${SUFFIX} ${image}
    done
  done

}

function delete_old_snapshots {

  for pool in ${POOLS[@]}; do
    images=$(rbd -p $pool ls 2>/dev/null)
    for image in $(echo $images); do
      snapshot_count=`rbd snap ls $pool/$image | grep -v "SNAPID" | egrep "$1" | wc -l`
      if [ "$snapshot_count" -gt "$SNAPSHOTS" ]; then 
        debug deleting $1 snapshots for: $pool/$image
        (( to_del = (( $snapshot_count - $SNAPSHOTS)) ))
        for((i=0;i<$to_del;i++)); do
          oldest_snapshot=`rbd snap ls $pool/$image | grep -v "SNAPID" | egrep "$1" |sort -n | head -n 1 | awk '{print $2}'`
          debug deleteing $pool/$image@$oldest_snapshot
          rbd snap rm $pool/$image@$oldest_snapshot
          if [ "$?" -gt "0" ] ; then
            debug fatal error can not delete snapshot $oldest_snapshot , it might be protected
          fi
        done
      else
        continue
      fi
    done
  done

}

function export_base_images {
  for pool in ${POOLS[@]}; do
    images=$(rbd -p $pool ls 2>/dev/null)
    for image in $(echo $images); do
      debug exporting BASE image $pool/$image $DEST/$pool/$image
      rbd export $pool/$image $DEST/$pool/$image/$image >/dev/null 2>&1
    done
  done

}

function export_diff_from_base_to_now {
  for pool in ${POOLS[@]}; do
    images=$(rbd -p $pool ls 2>/dev/null)
    for image in $(echo $images); do
      latest_base=`rbd snap ls $pool/$image | grep -v "SNAPID" | grep $BASEMARKER | sort -n | head -n 1 |awk '{print $2}'`
      latest_snap=`rbd snap ls $pool/$image | grep -v "SNAPID" | grep $MARKER | sort -n | head -n 1 |awk '{print $2}'`
      debug export-diff --from-snap $latest_base $pool/$image@$latest_snap $DEST/$pool/$image/${latest_base}-to-${latest_snap}
      rbd export-diff --from-snap $latest_base $pool/$image@$latest_snap $DEST/$pool/$image/${latest_base}-to-${latest_snap}  >/dev/null 2>&1
    done
  done

}

function update_index {

  if [ $CREATE_BASE == true ] ; then
    echo $SUFFIX "latest-base-image-here" >> $INDEX
  else
    echo $SUFFIX >> $INDEX
  fi
}


function retry_checker {

    tries=0
    echo "checking with command \"$*\""
    until eval $*; do
      rc=$?
      ((tries++))
      echo "try number $tries"
      echo "return code is $rc"
      if [ $tries -gt $CHECK_RETRIES ]; then
      failure=1
      break
    fi
      sleep 1
    done

}


function check_ready {

    #Uses a custom command to ensure a container is ready
    update_credentials
    failure=0
    echo "checking that node or service is available: $1 $2"
    case $1 in
      node) retry_checker "fuel node | grep '$2' | grep 'True'" ;;
      *) echo "No defined test for determining if $1 is ready.";;
    esac

    if [ $failure -eq 1 ]; then
      echo "ERROR: $1 failed to start."
      return 1
    else
      echo "$1 is ready."
      return 0
    fi

}

function update_credentials {

    credentialfile=$(mktemp /tmp/servicepws.XXXXX)
    $GSC $ASTUTE_YAML > $credentialfile
    . $credentialfile
    rm -f $credentialfile

}

function debug {

  if $DEBUG; then
    ${YELLOW}
    echo $@
    ${RESET}
  fi

}
