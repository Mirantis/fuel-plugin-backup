#!/bin/bash

DEBUG=true
CREATE_BASE=false

function show_usage {
    echo "Usage:"
    echo "  $0 command"
    echo
    echo "Available commands: (Note: work in progress)"
    echo "help: show this message"
    echo "Options:"
    ${GREEN}
    echo "  --debug    : to show some debug messages"
    ${RESET}
    echo "Commands  :"
    echo "  boot: to boot up node"
    echo
    echo "Examples:"

}

function parse_options {
    opts="$@"
    for opt in $@; do
      case $opt in
        -d|--debug)   DEBUG=true
                      shift
                      ;;
        --nodebug)    DEBUG=false
                      shift
                      ;;
        --)           shift
                      nonopts+=("$@")
                      return
                      ;;
        help|boot|deploy|start|stop|remove)
                      nonopts+=("$@")
                      return
                      ;;
        -*)           ${YELLOW}
                      echo "Unrecognized option: $opt" 1>&2
                      ${RESET}
                      exit 1
                      ;;
        *)            nonopts+=("$opt")
                      ;;
      esac
    done
}


function backup {

  pid

  list                                     ## Just information
  make_dir_if_not_exist                    ## Create Skeleton
  save_metadata                            ## Metadata, wiil use it to understand the image size

  create_not_create

  if [ $CREATE_BASE == true ] ; then
    create_base_snapshots                  ## Every day snapshot to make DIFF from base to it
    export_base_images                     ## Need to create if there is no Base images or other cases
  else
    create_today_snapshots                 ## Every day snapshot to make DIFF from base to it
    export_diff_from_base_to_now
  fi
    delete_old_snapshots                   ## If snapshot count more
    update_index                           ## User information about where base image is stored

}

function pid {
  # Am I Running
  if [ -f "${LCK_FILE}" ]; then
    MYPID=`head -n 1 $LCK_FILE`
    while [ -n "`ps -p ${MYPID} | grep ${MYPID}`" ]
    do
          echo `basename $0` is already running [$MYPID].
          exit
    done 
  fi
  echo $$ > $LCK_FILE
}

function create_not_create {

  #if there is no base images
  for pool in ${POOLS[@]}; do
    images=$(rbd -p $pool ls 2>/dev/null)
    for image in $(echo $images); do
      base_images_count=`rbd snap ls $pool/$image | grep -v "SNAPID" | grep base | sort -n | head -n 1 |awk '{print $2}' | wc -l`
      if [ "$base_images_count" -eq "0" ] ; then
        CREATE_BASE=true
      fi
    done
  done
  return
}

function make_dir_if_not_exist {

  if [ -d $DEST ]; then
    debug Destination folder already exists
  else
    debug "creating folder $DEST"
  fi
    for pool in ${POOLS[@]}; do
      debug creating $DEST/$pool
      mkdir -p $DEST/$pool
      images=$(rbd -p $pool ls 2>/dev/null)
      for image in $(echo $images); do
        debug creating $DEST/$pool/$image
        mkdir -p $DEST/$pool/$image
      done
    done

  debug "checking index file"
  if [ -e $INDEX ]; then
    debug $INDEX already exists
  else
     echo "#index file do not remove" > $INDEX
  fi

}

function list {

  for pool in ${POOLS[@]}; do
    debug list of images for pool $pool
    rbd -p $pool ls

    images=$(rbd -p $pool ls 2>/dev/null)
    for image in $(echo $images); do
      debug list of snapshots for_image $pool/$image
      rbd snap ls ${pool}/${image}
    done
  done
}

function purge {

  for pool in ${POOLS[@]}; do
    images=$(rbd -p $pool ls 2>/dev/null)
    for image in $(echo $images); do

      rbd snap ls ${pool}/${image}
      rbd snap purge ${pool}/${image}

    done
  done
}

function save_metadata {

  for pool in ${POOLS[@]}; do
    images=$(rbd -p $pool ls 2>/dev/null)
    debug Images: $images
    numimages=$(echo $images|sed '/^$/d'|wc -l)
    debug number of images $numimages
    if [ "$numimages" -eq 0 ]; then
        continue;
    fi
    echo $images > $DEST/$pool/images
    rados -p $pool get rbd_directory $DEST/$pool/rbd_directory

    for image in $(echo $images); do
        rbd -p $pool info $image > $DEST/$pool/$image.rbd
    done

  done

}

function create_base_snapshots {

  for pool in ${POOLS[@]}; do
    images=$(rbd -p $pool ls 2>/dev/null)
    for image in $(echo $images); do
      debug creating BASE snapshot for: $pool/$image with name ${BASEMARKER}-${image}-${SUFFIX}
      rbd -p $pool snap create --snap ${BASEMARKER}-${image}-${SUFFIX} ${image}
    done
  done

}
function create_today_snapshots {

  for pool in ${POOLS[@]}; do
    images=$(rbd -p $pool ls 2>/dev/null)
    for image in $(echo $images); do
      debug creating DAILY snapshot for: $pool/$image with name ${MARKER}-${image}-${SUFFIX}
      rbd -p $pool snap create --snap ${MARKER}-${image}-${SUFFIX} ${image}
    done
  done

}

function delete_old_snapshots {

  for pool in ${POOLS[@]}; do
    images=$(rbd -p $pool ls 2>/dev/null)
    for image in $(echo $images); do
      debug deleting snapshots for: $pool/$image
      snapshot_count=`rbd snap ls $pool/$image | grep -v "SNAPID" | egrep "$MARKER" | wc -l`
      if [ "$snapshot_count" -gt "$SNAPSHOTS" ]; then 
        (( to_del = (( $snapshot_count - $SNAPSHOTS)) ))
        for((i=0;i<$to_del;i++)); do
          oldest_snapshot=`rbd snap ls $pool/$image | grep -v "SNAPID" | egrep "$MARKER" |sort -n | head -n 1 | awk '{print $2}'`
          debug deleteing $pool/$image@$oldest_snapshot
          rbd snap rm $pool/$image@$oldest_snapshot
          if [ "$?" -gt "0" ] ; then
            debug fatal error can not delete snapshot $oldest_snapshot , it might be protected
          fi
        done
      else
        debug Nothing to delete
      fi
    done
  done

}

function export_base_images {
  for pool in ${POOLS[@]}; do
    images=$(rbd -p $pool ls 2>/dev/null)
    for image in $(echo $images); do
      debug exporting BASE image $pool/$image $DEST/$pool/$image
      rbd export $pool/$image $DEST/$pool/$image/$image >/dev/null 2>&1
    done
  done

}

function export_diff_from_base_to_now {
  for pool in ${POOLS[@]}; do
    images=$(rbd -p $pool ls 2>/dev/null)
    for image in $(echo $images); do
      latest_base=`rbd snap ls $pool/$image | grep -v "SNAPID" | grep $BASEMARKER | sort -n | head -n 1 |awk '{print $2}'`
      latest_snap=`rbd snap ls $pool/$image | grep -v "SNAPID" | grep $MARKER | sort -n | head -n 1 |awk '{print $2}'`
      debug export-diff --from-snap $latest_base $pool/$image@$latest_snap $DEST/$pool/$image/${latest_base}-to-${latest_snap}
      rbd export-diff --from-snap $latest_base $pool/$image@$latest_snap $DEST/$pool/$image/${latest_base}-to-${latest_snap}  >/dev/null 2>&1
    done
  done

}

function update_index {

  if [ $CREATE_BASE == true ] ; then
    echo $SUFFIX "latest-base-image-here" >> $INDEX
  else
    echo $SUFFIX >> $INDEX
  fi

}


function retry_checker {

    tries=0
    echo "checking with command \"$*\""
    until eval $*; do
      rc=$?
      ((tries++))
      echo "try number $tries"
      echo "return code is $rc"
      if [ $tries -gt $CHECK_RETRIES ]; then
      failure=1
      break
    fi
      sleep 1
    done

}


function check_ready {

    #Uses a custom command to ensure a container is ready
    update_credentials
    failure=0
    echo "checking that node or service is available: $1 $2"
    case $1 in
      node) retry_checker "fuel node | grep '$2' | grep 'True'" ;;
      *) echo "No defined test for determining if $1 is ready.";;
    esac

    if [ $failure -eq 1 ]; then
      echo "ERROR: $1 failed to start."
      return 1
    else
      echo "$1 is ready."
      return 0
    fi

}

function update_credentials {

    credentialfile=$(mktemp /tmp/servicepws.XXXXX)
    $GSC $ASTUTE_YAML > $credentialfile
    . $credentialfile
    rm -f $credentialfile

}

function debug {

  if $DEBUG; then
    ${YELLOW}
    echo $@
    ${RESET}
  fi

}
