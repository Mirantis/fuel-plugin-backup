#!/bin/bash

DEBUG=true
CREATE_BASE=false

function show_usage {
    echo "Usage:"
    echo "  $0 command"
    echo
    echo "Available commands: (Note: work in progress)"
    echo "help: show this message"
    echo "Options:"
    echo "  --debug    : to show some debug messages (by default)"
    echo "Commands  :"
    echo "  backup : to backup ceph data"
    echo "  restore: to restore backupped ceph data"
    echo "  list   : list all objects in rbd (developemnent option)"
    echo "  purge  : to remove all snapshots of all images (developemnent option)"
    echo
    echo "Examples:"
    echo "  $0 backup"
    echo "  $0 restore --folder /backup/$SUFFIX"

}

function parse_options {
    opts="$@"
    for opt in $@; do
      case $opt in
        -d|--debug)   DEBUG=true
                      shift
                      ;;
        --folder)     shift 2
                      SOURCE=$1
                      ;;
        --nodebug)    DEBUG=false
                      shift
                      ;;
        --)           shift
                      nonopts+=("$@")
                      return
                      ;;
        help|backup|purge|list)
                      nonopts+=("$@")
                      return
                      ;;
        -*)           ${YELLOW}
                      echo "Unrecognized option: $opt" 1>&2
                      ${RESET}
                      exit 1
                      ;;
        *)            nonopts+=("$opt")
                      ;;
      esac
    done
}


function backup {

  pid                                      ## Create lock-file
  list                                     ## Just information
  make_dir_if_not_exist                    ## Create Skeleton
  save_metadata                            ## Metadata, wiil use it to understand the image size
  create_snapshots $BASEMARKER             ## Every day snapshot to make DIFF from base to it
  export_base_images                       ## Need to create if there is no Base images or other cases
  export_diff_from_base_to_now
  delete_old_snapshots $BASEMARKER         ## If snapshot count more

}

function restore {

  pid
  check_the_path $SOURCE
#  import_base  $SOURCE
  import_diffs $SOURCE

}


function pid {
  # Am I Running
  if [ -f "${LCK_FILE}" ]; then
    MYPID=`head -n 1 $LCK_FILE`
    while [ -n "`ps -p ${MYPID} | grep ${MYPID}`" ]
    do
      echo `basename $0` is already running [$MYPID].
      exit
    done
  fi
  echo $$ > $LCK_FILE
}

function import_base {

  for pool in ${POOLS[@]}; do
    declare -a img=(`ls $BASEDEST/$pool/*.img | sed 's#.img$##'`)
    for i in ${img[@]} ; do
      debug import --image-format 2 ${i}.img `echo $i | sed 's#'$BASEDEST'/##'`
      rbd import --image-format 2 ${i}.img `echo $i | sed 's#'$BASEDEST'/##'`
    done
  done

}

function import_diffs {

  for pool in ${POOLS[@]}; do
    declare -a diffs=(`ls $1$MARKER/$pool/*.diff | sed 's#.diff$##' | sed 's#'$1'/daily/##'`)
    for i in ${diffs[@]} ; do
      debug import-diff ${i}.diff `echo $i | sed -e 's/^[0-9,a-z]*\/[0-9,a-z]*\///'`
#      rbd import-diff ${i}.diff `echo $i | `
    done
  done



}

function check_the_path {

  debug $1
  rc=`echo "$1" | grep $BACKUP &> /dev/null; echo $?`
  if [[ ! -e "$1" ]]; then
    ${RED}
    echo "Check the path, there is no such folder - $1"; 
    ${RESET}
    exit 1
  elif [[ "$rc" > "0" ]]; then
    ${RED}
    echo "Check the path, should be like $DEST"; 
    ${RESET}
    exit 1
  fi

}


function make_dir_if_not_exist {

  if [ -d $DEST ]; then
    debug Destination folder already exists
  else
    debug "creating folder $DEST"
  fi
    for pool in ${POOLS[@]}; do
      debug creating $DEST/$pool
      mkdir -p $DEST/$pool
      mkdir -p $BASEDEST/$pool
    done

}

function list {

  for pool in ${POOLS[@]}; do
    debug list of images for pool $pool
    rbd -p $pool ls

    images=$(rbd -p $pool ls 2>/dev/null)
    for image in $(echo $images); do
      debug list of snapshots for_image $pool/$image
      rbd snap ls ${pool}/${image}
    done
  done
}

function purge {

  for pool in ${POOLS[@]}; do
    images=$(rbd -p $pool ls 2>/dev/null)
    for image in $(echo $images); do

      rbd snap ls ${pool}/${image}
      rbd snap purge ${pool}/${image}

    done
  done
}

function save_metadata {

  for pool in ${POOLS[@]}; do
    images=$(rbd -p $pool ls 2>/dev/null)
    debug Images: $images
    numimages=$(echo $images|sed '/^$/d'|wc -l)
    debug number of images $numimages
    if [ "$numimages" -eq 0 ]; then
        continue;
    fi
    echo $images > $DEST/$pool/images
    rados -p $pool get rbd_directory $DEST/$pool/rbd_directory

    for image in $(echo $images); do
        rbd -p $pool info $image > $DEST/$pool/$image.info
    done

  done

}

function create_snapshots {

  for pool in ${POOLS[@]}; do
    images=$(rbd -p $pool ls 2>/dev/null)
    for image in $(echo $images); do
      base_images_count=`rbd snap ls $pool/$image | grep -v "SNAPID" | grep base | sort -n | head -n 1 | awk '{print $2}' | wc -l`
      if [ "$base_images_count" -eq "0" ] ; then
        debug creating $1 snapshot for: $pool/$image with name $1-${image}-${SUFFIX}
        rbd -p $pool snap create --snap $1-${image}-${SUFFIX} ${image}
      fi

    done
  done

}

function delete_old_snapshots {


  folder_count=`ls /backup | grep -v $1 | sort -n | wc -l`
  (( to_del = (( $folder_count - $SNAPSHOTS)) ))
  declare -a old_folders=(`ls /backup | grep -v base | sort -r | tail -n $to_del`)
  for i in ${old_folders[@]} ; do
    debug deleting old data from  /backup/$i
    rm -rf /backup/$i
  done
}

function export_base_images {

  for pool in ${POOLS[@]}; do
    images=$(rbd -p $pool ls 2>/dev/null)
    for image in $(echo $images); do
      if [ ! -e "$BASEDEST/$pool/${image}.img" ] ; then 
        debug exporting BASE image $pool/$image $BASEDEST/$pool/$image.img
        rbd export $pool/$image $BASEDEST/$pool/${image}.img >/dev/null 2>&1
      fi 
    done
  done

}

function export_diff_from_base_to_now {
  for pool in ${POOLS[@]}; do
    images=$(rbd -p $pool ls 2>/dev/null)
    for image in $(echo $images); do
      latest_base=`rbd snap ls $pool/$image | grep -v "SNAPID" | grep $BASEMARKER | sort -n | head -n 1 |awk '{print $2}'`
      if [ ! -e "$DEST/$pool/${image}.diff" ] ; then 
        debug export-diff $pool/$image --from-snap $latest_base $DEST/$pool/$image.diff
        rbd export-diff $pool/$image --from-snap $latest_base $DEST/$pool/${image}.diff >/dev/null 2>&1
      fi
    done
  done

}


function retry_checker {

    tries=0
    echo "checking with command \"$*\""
    until eval $*; do
      rc=$?
      ((tries++))
      echo "try number $tries"
      echo "return code is $rc"
      if [ $tries -gt $CHECK_RETRIES ]; then
      failure=1
      break
    fi
      sleep 1
    done

}


function check_ready {

    #Uses a custom command to ensure a container is ready
    update_credentials
    failure=0
    echo "checking that node or service is available: $1 $2"
    case $1 in
      node) retry_checker "fuel node | grep '$2' | grep 'True'" ;;
      *) echo "No defined test for determining if $1 is ready.";;
    esac

    if [ $failure -eq 1 ]; then
      echo "ERROR: $1 failed to start."
      return 1
    else
      echo "$1 is ready."
      return 0
    fi

}

function update_credentials {

    credentialfile=$(mktemp /tmp/servicepws.XXXXX)
    $GSC $ASTUTE_YAML > $credentialfile
    . $credentialfile
    rm -f $credentialfile

}

function debug {

  if $DEBUG; then
    ${YELLOW}
    echo $@
    ${RESET}
  fi

}
